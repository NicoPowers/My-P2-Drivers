{Object_Title_and_Purpose}


CON
  _clkfreq = 200_000_000
  baud_rate = 12_000_000 ' full speed
  D_P   = 1 ' upper
  D_M   = 0 ' lower
  D_M_MODE = P_USB_PAIR | P_OE
  D_P_MODE = P_USB_PAIR | P_OE | P_HIGH_1K5
  SETUP_PID       = $2D
  EOP_BM          = (1 << 5)
  SOP_BM          = (1 << 4)
  TIMEOUT_DELAY   = 1000

VAR

BYTE dataRec[20]

PUB main()  | recording, temp, currentByte, lastByte, numReads, toggleBit, prevToggleBit

numReads := 0
toggleBit := 0

temp := muldiv64(baud_rate,$10000,clkfreq)

coginit(newcog, @INIT_USB, @temp)

'pinstart(D_M, D_M_MODE, $6666, 0) ' lower pin establishes USB mode and baud rate
'pinstart(D_P, D_P_MODE, 0 ,0) ' upper pin establishes USB Pullup for Full Speed mode


'_wait_for_in(D_M)







DAT

org
INIT_USB
        dirl #D_P                                       ' clear dir bits
        dirl #D_M

                                                        ' configure lower pin mode
        WRPIN ##D_M_MODE, #D_M

                                                        ' configure upper pin mode
        WRPIN ##D_P_MODE, #D_P


        WXPIN ##$4F5C, #D_M                             ' set USB for device mode and full speed baud rate (lower pin, D_M)

                                                        ' set pins' dir to start USB
        dirh #D_P
        dirh #D_M

        DRVL  #3
        JMP   #SETUP_STAGE

' START USB FSM

PULSE_2
        DRVNOT            #2
        WAITX             ##1
        DRVNOT            #2
        RET

PULSE_3
        DRVNOT            #3
        WAITX             ##1
        DRVNOT            #3
        RET

WAIT_BYTE
        TESTP           #D_M    WC
        IF_NC           JMP     #WAIT_BYTE
        RDPIN           D,      #D_M
        SHR             D,      #8    WC      'get byte into D, get toggle bit into C
        BITC            currC,  #0
        CMPS            prevC,  currC WZ
        MOV             prevC,  currC
        IF_E            JMP     #WAIT_BYTE
        RET

WAIT_SOP
        TESTP           #D_M    WC
        IF_NC           JMP     #WAIT_SOP
        RDPIN           D,      #D_M
        TESTB           D,      #4 WZ
        TESTB           D,      #7 WC
        BITC            currC,  #0
        MOV             prevC,  currC
        IF_NZ           JMP     #WAIT_SOP
        RET

WAIT_EOP
        TESTP           #D_M    WC
        IF_NC           JMP     #WAIT_EOP
        RDPIN           D,      #D_M
        TESTB           D,      #5 WZ
        TESTB           D,      #7 WC
        BITC            currC,  #0
        MOV             prevC,  currC
        IF_NZ           JMP     #WAIT_EOP
        RET

WAIT_SETUP
        MOV             setupFound, #0
        CALL            #WAIT_BYTE
        CMP             D, #SETUP_PID WZ
        IF_E            MOV setupFound, #1
        RET



SETUP_STAGE



        ' wait for SOP Byte
        CALL            #WAIT_SOP
        CALL            #PULSE_2

        ' wait for possible SETUP byte (0x2D)
        CALL            #WAIT_SETUP

        ' if setup byte was found within reasonable amount of time, this is a valid SETUP transaction

        CMPS            setupFound, #1
        IF_E            CALL    #PULSE_3

        CALL            #WAIT_EOP
        CALL            #PULSE_2



        JMP             #SETUP_STAGE



DONE    JMP   #DONE


{
EVAL_NEW_BYTE
        CMP             D,      #$80  WZ
        IF_Z            DRVNOT  #3
        RET
}
' There are 4 different packet formats we need to be able to read

' Token
' Data
' Handshake
' SOF

{
INIT_WAIT_SETUP
        GETCT           currClocks
        MOV             endClocks, currClocks
        ADD             endClocks, ##333333
        JMP             #WAIT_SETUP


FOUND_SETUP
        DRVL            #2
        DRVH            #2
        JMP             #WAIT_SYNC


WAIT_SETUP '(0x2D)
        ' make sure we haven't waited more than 400 cycles
        GETCT           currClocks
        CMP             currClocks, endClocks WC
        IF_GE           JMP     #WAIT_SYNC
        RDPIN           D,      #D_M
        SHR             D,      #8    WC      'get byte into D, get toggle bit into C
        CMP             D,      #$2D  WZ
        IF_Z            JMP     #FOUND_SETUP
        JMP             #WAIT_SETUP

READ_DATA
        RDPIN   D, #D_M
        ' determine if this packet represents an EOP
        'TEST D, #(1 << 5) WZ
        'IF_NZ CALL #EOP_FRAME
        SHR     D,#8    WC      'get byte into D, get toggle bit into C
        BITC    currC, #0
        CMPSUB  prevC, currC WZ
        IF_NE   DRVNOT #2
        MOV     prevC, currC
        JMP     #READ_DATA

' if we received an EOP, let's clear the status register for the receiver and start collecting bytes now
EOP_FRAME
        DRVNOT #3
        RET

EVAL_BYTE
        DRVNOT #2
        CMP    D, #$A5 WZ
        IF_Z   DRVNOT #3
        RET

}
currClocks                      LONG            0
endClocks                       LONG            0
D                               LONG            0
prevC                           LONG            2
currC                           LONG            0
addrField                       LONG            0
endpField                       LONG            0
timeout                         LONG            1
ct1                             LONG            1
ct2                             LONG            1
setupFound                      LONG            0