VAR

long clk_m, clk_x, mosi_m, mosi_x, miso_m, miso_x
long spi_clk_pin, spi_mosi_pin, spi_miso_pin
long spi_isInitialized


PUB SPI_INIT(clk_pin, mosi_pin, miso_pin, spi_mode, frequency) : status | displacement, modified_frequency

' verify correct spi_mode is entered (0-3)
if spi_mode < 0 || spi_mode > 3
  debug("ERROR: incorrect spi_mode")
  status := -1
  return

' verify that the input frequency is in between is not too slow or too fast, inclusive ($FFFF is the max value that can be stored and value of $0 would do nothing)
modified_frequency := clkfreq / frequency / 2
if modified_frequency < $1 || modified_frequency > $FFFF
  debug("ERROR: incorrect frequency")
  status := -1
  return


' verify that the mosi pin is not too far away from the clk and check for pin uniqueness
if abs(mosi_pin - clk_pin) > 3
  debug("ERROR: mosi pin too far away from clk pin")
  status := -1
  return
elseif (mosi_pin == clk_pin)
  debug("ERROR: mosi pin cannot be the same as clk pin")
  status := -1
  return

' verify that the msio pin is not too far away from the clk and check for pin uniqueness
if abs(miso_pin - clk_pin) > 3
  debug("ERROR: miso pin too far away from clk pin")
  status := -1
  return
elseif (miso_pin == clk_pin)
  debug("ERROR: miso pin cannot be the same as clk pin")
  status := -1
  return

' verify that the mosi pin is not the same as the miso pin
if (miso_pin == mosi_pin)
  debug("ERROR: miso pin cannot be the same as miso pin")
  status := -1
  return



' initialize the SPI pins
spi_clk_pin   := clk_pin
spi_mosi_pin  := mosi_pin
spi_miso_pin  := miso_pin

' initialize mode for clk, mosi, and miso
clk_m   := $0000_0000 | P_OE | P_TRANSITION
mosi_m  := $0000_0000 | P_OE | P_SYNC_TX
miso_m  := $0000_0000 | P_SYNC_RX

' initialize x register data for clk, mosi, and miso (using start-stop method for miso and mosi)
clk_x   := modified_frequency
mosi_x  := $0000_0000 | (1 << 5)
miso_x  := $0000_0000 | (1 << 5)

' determine P_MINUS_B value for miso and mosi (clock is the B signal)
displacement := clk_pin - mosi_pin
mosi_m |= ((displacement & 7) << 24)
displacement := clk_pin - miso_pin
miso_m |= ((displacement & 7) << 24)


case spi_mode
  ' CPOL = 0 & CPHA = 0
  0:
    ' change SPI MOSI to shift out data on falling edge
    mosi_m |= P_INVERT_B

  ' CPOL = 0 & CPHA = 1
  1:
    ' change SPI MISO to sample data on falling edge
    miso_m |= P_INVERT_B

  ' CPOL = 1 & CPHA = 1
  2:
    ' change SPI MISO to sample data on falling edge
    miso_m |= P_INVERT_B
    ' change clock to idle on HIGH
    clk_m |= P_INVERT_OUTPUT

  ' CPOL = 1 & CPHA = 0
  3:
   ' change SPI MOSI to shift out data on falling edge
    mosi_m |= P_INVERT_B
    ' change clock to idle on HIGH
    clk_m |= P_INVERT_OUTPUT


' start SPI CLK with no transitions
pinstart(clk_pin, clk_m, clk_x, 0)

' start SPI MOSI with an empty buffer
pinstart(mosi_pin, mosi_m, mosi_x, 0)

spi_isInitialized := true


PUB SPI_TRANSFER(data, bitsToTransfer, isLSB) : dataReadMod | dataWriteMod

if spi_isInitialized
 ' verify that the number of bits is valid
  if bitsToTransfer < 1 or bitsToTransfer > 32
    return

  ' if we need to send MSB, reorder the data since smart pins will send it LSB
  dataWriteMod := data
  if !isLSB
    if (bitsToTransfer < 32)
      dataWriteMod <<= (32-bitsToTransfer)
    dataWriteMod := data rev 31

  ' setup MOSI
  mosi_x := (mosi_x & $FFE0) | (bitsToTransfer - 1)
  WXPIN(spi_mosi_pin, mosi_x)
  WYPIN(spi_mosi_pin, dataWriteMod)
  ' setup MISO
  miso_x := (miso_x & $FFE0) | (bitsToTransfer - 1)
  WXPIN(spi_miso_pin, miso_x)
  ' start clocking
  WYPIN(spi_clk_pin, bitsToTransfer*2)
  ' wait until the clock stops
  waitForIN(spi_clk_pin)

  ' if we need to receive MSB, reorder the data since smart pins will receive it LSB
  dataReadMod := RDPIN(spi_miso_pin)
  if !isLSB
    if (bitsToTransfer < 32)
      dataReadMod >>= (32-bitsToTransfer)
    dataReadMod := dataReadMod rev 31
    dataReadMod := dataReadMod zerox (bitsToTransfer - 1)

PRI waitForIN(pin)

org

WAIT_IN
testp pin wc
nop                             ' get state of IN bit for smart pin, store in C
if_c jmp #IN_SET                ' if C is set (IN = 1), branch to IN_SET
jmp #WAIT_IN                    ' if C is NOT set, go back to WAIT_IN to continue polling

IN_SET
akpin pin                       ' ack IN to clear it

end
